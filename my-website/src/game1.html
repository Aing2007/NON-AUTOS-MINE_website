<!doctype html>
<html lang="th">

<head>
    <meta charset="utf-8" />
    <title>เกมรู้จักใบหน้า - Transition + Pose Model</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial;
            background: #7172DC;
            transition: background .5s;
            overflow: hidden;
        }

        body.bg-white {
            background: #fff !important;
        }

        .center-img {
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            max-width: min(50vw, 600px);
            width: 100%;
            height: auto;
            display: block;
            animation: fadein .7s;
            z-index: 10;
            transition: left .7s, top .7s, transform .7s;
        }

        .center-img.to-left {
            left: 25%;
            top: 50%;
            transform: translate(-50%, -50%);
        }

        .split-container {
            position: fixed;
            inset: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            transition: background .5s;
        }

        .split-left,
        .split-right {
            width: 50vw;
            height: 100vh;
            position: relative;
            transition: box-shadow .5s;
        }

        .split-left {
            background: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 32px 0 rgba(113, 114, 220, .08);
            z-index: 2;
        }

        .split-right {
            background: #111;
            box-shadow: 0 0 32px 0 rgba(113, 114, 220, .08);
            z-index: 1;
            overflow: hidden;
        }

        @keyframes fadein {
            from {
                opacity: 0;
                transform: scale(.8)
            }

            to {
                opacity: 1;
                transform: scale(1)
            }
        }

        .center-number {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(60px, 12vw, 300px);
            font-weight: 800;
            color: #fff;
            z-index: 20;
            pointer-events: none;
            user-select: none;
            text-shadow: 0 2px 8px rgba(0, 0, 0, .3);
            transition: opacity .5s;
        }

        .center-number.hide {
            opacity: 0;
        }

        .transition-mask {
            position: fixed;
            inset: 0;
            background: #fff;
            z-index: 99;
            pointer-events: none;
            opacity: 0;
            transition: opacity .7s;
        }

        .transition-mask.show {
            opacity: 1;
        }

        .stage {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #111;
        }

        video,
        canvas {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
        }

        video {
            object-fit: contain;
            background: #111;
            transform: scaleX(-1);
        }

        #overlay {
            pointer-events: none;
            z-index: 5;
        }

        .hud {
            position: absolute;
            left: 8px;
            bottom: 5px;
            display: flex;
            gap: 8px;
            align-items: center;
            background: rgba(0, 0, 0, .30);
            padding: 6px 10px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, .08);
            font-size: .8vw;
            line-height: 1.2;
            height: 1.8vw;
            z-index: 10;
        }

        .badge {
            padding: 2px 6px;
            border-radius: 6px;
            background: rgba(255, 255, 255, .04);
            border: 1px solid rgba(255, 255, 255, .08)
        }

        .dot {
            width: 1vw;
            height: 1vw;
            border-radius: 50%;
            display: inline-block;
            margin-right: 6px;
            background: #b33
        }

        .dot.on {
            background: #29c26f
        }

        .next-btn {
            position: absolute;
            right: 24px;
            bottom: 24px;
            background: #0a502f;
            color: #fff;
            text-decoration: none;
            font-weight: 700;
            font-size: 1.2vw;
            padding: 12px 18px;
            border-radius: 10px;
            border: 1px solid #169b1a;
            transition: transform .1s ease, filter .1s ease;
            z-index: 20
        }

        .next-btn:hover {
            transform: translateY(-1px);
            filter: saturate(1.05)
        }

        #pose-label-container {
            position: absolute;
            top: 12px;
            right: 24px;
            z-index: 30;
            background: rgba(255, 255, 255, .12);
            border-radius: 12px;
            padding: 12px 18px;
            color: #fff;
            font-size: 1.1em;
            font-weight: 600;
            box-shadow: 0 2px 12px rgba(0, 0, 0, .08)
        }

        .tm-mini {
            position: absolute;
            top: 12px;
            right: 12px;
            width: 25%;
            aspect-ratio: 4/3;
            background: rgba(0, 0, 0, .32);
            border: 1px solid rgba(255, 255, 255, .18);
            border-radius: 14px;
            overflow: hidden;
            z-index: 40;
            backdrop-filter: blur(4px);
            box-shadow: 0 8px 24px rgba(0, 0, 0, .25);
            pointer-events: none
        }

        .tm-mini canvas {
            width: 100%;
            height: 100%;
            display: block
        }

        .tm-badge {
            position: absolute;
            left: 10px;
            top: 10px;
            z-index: 41;
            background: rgba(0, 0, 0, .55);
            color: #fff;
            font-weight: 700;
            font-size: 12px;
            padding: 6px 10px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, .1);
            pointer-events: none
        }

        /* ====== แผงกราฟคะแนนความร่วมมือ (ด้านขวา) ====== */
        .results-panel {
            position: absolute;
            top: 50%;
            right: 12px;
            transform: translateY(-50%);
            width: 22%;
            max-width: 360px;
            min-width: 220px;
            background: rgba(255, 255, 255, .06);
            border: 1px solid rgba(255, 255, 255, .18);
            border-radius: 14px;
            padding: 12px;
            color: #fff;
            z-index: 45;
            backdrop-filter: blur(4px);
            box-shadow: 0 8px 24px rgba(0, 0, 0, .25);
        }

        .results-title {
            font-weight: 800;
            margin: 0 0 8px 0;
            font-size: 14px;
            opacity: .95;
        }

        .bar-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 8px 0;
        }

        .bar-label {
            width: 38%;
            font-size: 12px;
            opacity: .9;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .bar {
            flex: 1;
            height: 14px;
            background: rgba(255, 255, 255, .12);
            border-radius: 999px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, .18);
        }

        .bar>.fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #60a5fa, #22c55e);
            transition: width .25s ease-out;
        }

        .bar-val {
            width: 42px;
            text-align: right;
            font-size: 12px;
            opacity: .9;
        }

        @media (max-width:900px) {
            .split-container {
                flex-direction: column
            }

            .split-right {
                width: 100vw;
                height: 50vh
            }

            .next-btn {
                font-size: 3vw
            }

            .hud {
                font-size: 2vw;
                height: 4vw
            }

            .tm-mini {
                width: 38%
            }

            .results-panel {
                width: 44%;
                right: 8px;
                top: auto;
                bottom: 8px;
                transform: none;
            }
        }
    </style>
</head>

<body>
    <div class="center-number" id="centerNumber">1</div>

    <!-- ใช้ path ของคุณตามจริงได้เลย (แนะนำ path relative แทน absolute) -->
    <img id="gameImg" src="./image/game/image 67.png" alt="เกมรู้จักใบหน้า" class="center-img" style="display:none;" />

    <div class="transition-mask" id="mask"></div>

    <div class="split-container" id="splitContainer" style="display:none;">
        <div class="split-left">
            <img src="./image/game/image 67.png" alt="เกมรู้จักใบหน้า" class="center-img to-left" />
        </div>
        <div class="split-right">
            <div class="stage">
                <video id="video" autoplay playsinline muted></video>
                <canvas id="overlay"></canvas>
                <canvas id="pose-canvas"></canvas>
                <div id="pose-label-container"></div>

                <!-- Mini TM Pose -->
                <div id="tmMini" class="tm-mini">
                    <span id="tmBadge" class="tm-badge">Pose</span>
                    <canvas id="tmMiniCanvas"></canvas>
                </div>

                <!-- ===== พาเนลกราฟคะแนนความร่วมมือ ===== -->
                <div class="results-panel" id="resultsPanel">
                    <p class="results-title" id="resultsTitle">คะแนนความร่วมมือ Realtime</p>
                    <div id="bars"></div>
                </div>
            </div>

            <div class="hud">
                <span class="badge"><span id="wsDot" class="dot"></span><span id="wsStatus">WS:
                        disconnected</span></span>
                <span class="badge">Cam: <span id="camInfo">—</span></span>
                <span class="badge">Tx: <span id="sendFps">0</span> fps</span>
                <span class="badge">Rx: <span id="recvFps">0</span> fps</span>
                <span class="badge">Latency: <span id="lat">—</span> ms</span>
            </div>

            <a href="checkgame1.html" id="nextBtn" class="next-btn">เสร็จสิ้น →</a>
        </div>
    </div>

    <!-- TM Pose libs -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.3.1/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@teachablemachine/pose@0.8/dist/teachablemachine-pose.min.js"></script>

    <script>
        const DRAW_POSE_ON_MAIN = false;

        /* =================== TTS =================== */
        function speak(text, cb) {
            if (!("speechSynthesis" in window)) return cb && cb();
            const u = new SpeechSynthesisUtterance(text);
            u.lang = "en-US"; u.rate = 0.9; u.pitch = 1.2;
            u.onend = () => cb && cb();
            u.onerror = () => cb && cb();

            const speakNow = () => { try { speechSynthesis.cancel(); speechSynthesis.speak(u); } catch { cb && cb(); } };

            const tryVoices = () => {
                const vs = speechSynthesis.getVoices();
                if (vs && vs.length) speakNow();
                else setTimeout(speakNow, 300);
            };

            if (!speechSynthesis.getVoices().length) {
                speechSynthesis.onvoiceschanged = tryVoices;
                setTimeout(tryVoices, 200);
            } else {
                speakNow();
            }
        }
        const welcomeText = "Hello everyone, today let's play the 'Know Your Faces' game. Let's start with Level 1.";
        const afterText = "Have the child look at the picture and tell what emotion it represents. Why does he have tears? Is it crying? If they understand, they can start to make the face as it shown.";

        /* =================== Globals =================== */
        let boxesA = []; // human
        let boxesB = []; // animal
        let srcW = 0, srcH = 0;

        window.__latestPose = null;
        window.__latestPoseTop = null;

        const CoopState = {};
        const COLOR_POOL = ['#22c55e', '#60a5fa', '#f59e0b', '#f43f5e', '#a78bfa', '#10b981', '#ef4444', '#14b8a6', '#eab308', '#8b5cf6'];
        let colorIdx = 0;
        const COLOR_BY_LABEL = {};
        const colorFor = (label) => {
            if (!COLOR_BY_LABEL[label]) COLOR_BY_LABEL[label] = COLOR_POOL[colorIdx++ % COLOR_POOL.length];
            return COLOR_BY_LABEL[label];
        };

        const SCORE_CFG = {
            maxHumanSpeedGood: 0.020,
            maxAnimalSpeedGood: 0.015,
            minPresenceMs: 1500,
            wHumanSteady: 0.45,
            wAnimalStable: 0.25,
            wPose: 0.30,
            sampleWindowMs: 5000
        };

        function centerOf(b) { return { cx: b.x + b.w / 2, cy: b.y + b.h / 2 }; }
        function diagOf(w, h) { return Math.hypot(w, h) || 1; }
        function clamp01(x) { return Math.max(0, Math.min(1, x)); }
        function clamp100(x) { return Math.max(0, Math.min(100, x)); }

        function isAnimalAboveHuman(an, hu) {
            const anBottom = an.y + an.h, huTop = hu.y;
            const xOverlap = !(an.x + an.w < hu.x || an.x > hu.x + hu.w);
            return (anBottom <= huTop) && xOverlap;
        }

        function rectCenter(b) { return { x: b.x + b.w / 2, y: b.y + b.h / 2 }; }
        function rectIntersectArea(a, b) {
            const x1 = Math.max(a.x, b.x);
            const y1 = Math.max(a.y, b.y);
            const x2 = Math.min(a.x + a.w, b.x + b.w);
            const y2 = Math.min(a.y + a.h, b.y + b.h);
            const w = Math.max(0, x2 - x1);
            const h = Math.max(0, y2 - y1);
            return w * h;
        }
        function rectIoU(a, b) {
            const inter = rectIntersectArea(a, b);
            const union = a.w * a.h + b.w * b.h - inter;
            return union > 0 ? inter / union : 0;
        }

        function pairAnimalsWithHumans(animals, humans) {
            const pairs = [];
            for (const an of animals) {
                const label = String(an.label || an.class || an.src || 'animal');

                // 1) ทับกัน → มากสุด
                const overlapCands = humans
                    .map(h => ({ human: h, area: rectIntersectArea(an, h), iou: rectIoU(an, h) }))
                    .filter(o => o.area > 0);

                if (overlapCands.length > 0) {
                    overlapCands.sort((a, b) => (b.area - a.area) || (b.iou - a.iou));
                    pairs.push({ label, animal: an, human: overlapCands[0].human });
                    continue;
                }

                // 2) เหนือศีรษะ (fallback เดิม)
                let bestAbove = null, bestDy = Infinity;
                for (const hu of humans) {
                    if (!isAnimalAboveHuman(an, hu)) continue;
                    const dy = Math.max(0, hu.y - (an.y + an.h));
                    if (dy < bestDy) { bestDy = dy; bestAbove = hu; }
                }
                if (bestAbove) { pairs.push({ label, animal: an, human: bestAbove }); continue; }

                // 3) ใกล้ที่สุด
                const ac = rectCenter(an);
                let bestNear = null, bestDist = Infinity;
                for (const hu of humans) {
                    const hc = rectCenter(hu);
                    const d = Math.hypot(ac.x - hc.x, ac.y - hc.y);
                    if (d < bestDist) { bestDist = d; bestNear = hu; }
                }
                if (bestNear) pairs.push({ label, animal: an, human: bestNear });
            }
            return pairs;
        }

        /* =================== แปลงกล่อง/สเกลตามขนาดวิดีโอจริง =================== */
        function parseServerMessageToBoxes(msg, video) {
            const vw = video.videoWidth || 1920;
            const vh = video.videoHeight || 1080;

            let a = msg.boxesA || msg.boxes_human || msg.humans || [];
            let b = msg.boxesB || msg.boxes_animal || msg.animals || [];

            if ((!a.length && !b.length) && Array.isArray(msg.detections)) {
                const low = s => (s || '').toLowerCase();
                a = msg.detections.filter(o => low(o.class || o.label) === 'human' || low(o.src || '').includes('human'));
                b = msg.detections.filter(o => low(o.class || o.label) === 'animal' || low(o.src || '').includes('animal'));
            }
            if ((!a.length && !b.length) && Array.isArray(msg.boxes)) {
                const all = msg.boxes, low = s => (s || '').toLowerCase();
                a = all.filter(bb => low(bb.class || bb.label || bb.src).includes('human'));
                b = all.filter(bb => low(bb.class || bb.label || bb.src).includes('animal'));
                if (!a.length && !b.length) a = all;
            }

            if (typeof msg.w === 'number') srcW = msg.w;
            if (typeof msg.h === 'number') srcH = msg.h;

            const BW = srcW || vw, BH = srcH || vh;

            const toPixels = (bb) => {
                if (!bb) return bb;
                let x = +bb.x, y = +bb.y, w = +bb.w, h = +bb.h;
                const norm = (w <= 1.5 && h <= 1.5);
                return norm
                    ? { ...bb, x: x * BW, y: y * BH, w: w * BW, h: h * BH }
                    : { ...bb, x, y, w, h };
            };
            boxesA = (a || []).map(toPixels);
            boxesB = (b || []).map(toPixels);
        }

        function updateCooperationForPairs(pairs, nowMs) {
            const W = srcW || 1920, H = srcH || 1080, diag = diagOf(W, H);
            const poseProb = (window.__latestPoseTop?.prob || 0);

            for (const { label, animal, human } of pairs) {
                if (!CoopState[label]) {
                    CoopState[label] = {
                        color: colorFor(label),
                        lastHumanCXN: null, lastHumanCYN: null,
                        lastAnCXN: null, lastAnCYN: null,
                        lastT: nowMs,
                        speedHumanEma: 0, speedAnimalEma: 0,
                        presentStreakMs: 0,
                        scoreNow: 0,
                        samples5s: [],
                        lastBucketTs: nowMs
                    };
                }
                const st = CoopState[label];

                const hc = centerOf(human), ac = centerOf(animal);
                const hxn = hc.cx / W, hyn = hc.cy / H;
                const axn = ac.cx / W, ayn = ac.cy / H;

                const dt = Math.max(1, nowMs - (st.lastT || nowMs)) / 1000.0;

                let vH = 0, vA = 0;
                if (st.lastHumanCXN != null) {
                    const dh = Math.hypot((st.lastHumanCXN - hxn) * W, (st.lastHumanCYN - hyn) * H) / diag;
                    vH = dh / dt;
                }
                if (st.lastAnCXN != null) {
                    const da = Math.hypot((st.lastAnCXN - axn) * W, (st.lastAnCYN - ayn) * H) / diag;
                    vA = da / dt;
                }

                st.speedHumanEma = (st.lastHumanCXN == null) ? vH : (0.35 * vH + 0.65 * st.speedHumanEma);
                st.speedAnimalEma = (st.lastAnCXN == null) ? vA : (0.35 * vA + 0.65 * st.speedAnimalEma);

                st.lastHumanCXN = hxn; st.lastHumanCYN = hyn;
                st.lastAnCXN = axn; st.lastAnCYN = ayn;
                st.lastT = nowMs;

                st.presentStreakMs += (dt * 1000);

                const humanSteady = clamp100(100 * (1 - (st.speedHumanEma / SCORE_CFG.maxHumanSpeedGood)));
                const animalStableRaw = clamp100(100 * (1 - (st.speedAnimalEma / SCORE_CFG.maxAnimalSpeedGood)));
                const presenceFactor = clamp01(st.presentStreakMs / SCORE_CFG.minPresenceMs);
                const animalStable = animalStableRaw * presenceFactor;
                const posePct = clamp100(poseProb * 100);

                const score = (SCORE_CFG.wHumanSteady * humanSteady) +
                    (SCORE_CFG.wAnimalStable * animalStable) +
                    (SCORE_CFG.wPose * posePct);
                st.scoreNow = clamp100(score);
            }

            const alive = new Set(pairs.map(p => p.label));
            for (const [label, st] of Object.entries(CoopState)) {
                if (!alive.has(label)) st.presentStreakMs = 0;
            }

            window.__coopByAnimal = Object.fromEntries(
                Object.entries(CoopState).map(([label, st]) => [label, st.scoreNow])
            );

            // เก็บตัวอย่างคะแนนทุก 5 วิ
            for (const [label, st] of Object.entries(CoopState)) {
                if (nowMs - (st.lastBucketTs || 0) >= SCORE_CFG.sampleWindowMs) {
                    st.lastBucketTs = nowMs;
                    const v = Math.round(clamp100(st.scoreNow || 0));
                    st.samples5s.push(v);
                    if (st.samples5s.length > 24) st.samples5s.shift(); // ~2 นาทีล่าสุด
                }
            }
        }

        function finalizeCooperation() {
            const result = {};
            for (const [label, st] of Object.entries(CoopState)) {
                let arr = st.samples5s.slice();
                if (arr.length === 0) arr = [clamp100(st.scoreNow || 0)];
                const avg = clamp100(arr.reduce((a, b) => a + b, 0) / arr.length);
                result[label] = Math.round(avg);
            }
            window.__finalCoopPerAnimal = result;
            try { localStorage.setItem('finalCoop', JSON.stringify({ ts: Date.now(), data: result })); } catch { }
            return result;
        }

        /* ===== กราฟคะแนนความร่วมมือ (ผลสด) ===== */
        function renderBars(showFinal = false) {
            const titleEl = document.getElementById('resultsTitle');
            const barsEl = document.getElementById('bars');
            if (!barsEl) return;

            let dataEntries = [];

            if (showFinal && window.__finalCoopPerAnimal) {
                titleEl.textContent = 'ผลเฉลี่ย (ล็อกก่อนย้ายหน้า)';
                dataEntries = Object.entries(window.__finalCoopPerAnimal)
                    .map(([label, score]) => ({ label, score, color: CoopState[label]?.color || '#60a5fa' }));
            } else {
                titleEl.textContent = 'คะแนนความร่วมมือ (สด)';
                dataEntries = Object.entries(CoopState)
                    .map(([label, st]) => ({ label, score: Math.round(st.scoreNow || 0), color: st.color || '#60a5fa' }));
            }

            const existing = new Set();
            for (const { label, score, color } of dataEntries.sort((a, b) => b.score - a.score)) {
                existing.add(label);
                let row = document.getElementById('bar-' + label);
                if (!row) {
                    row = document.createElement('div');
                    row.className = 'bar-row';
                    row.id = 'bar-' + label;
                    row.innerHTML = `
            <div class="bar-label"></div>
            <div class="bar"><div class="fill"></div></div>
            <div class="bar-val">0%</div>
          `;
                    barsEl.appendChild(row);
                }
                row.querySelector('.bar-label').textContent = label;
                const fill = row.querySelector('.fill');
                fill.style.width = `${score}%`;
                fill.style.background = `linear-gradient(90deg, ${color}, #22c55e)`;
                row.querySelector('.bar-val').textContent = `${score}%`;
            }

            if (!showFinal) {
                Array.from(barsEl.querySelectorAll('.bar-row')).forEach(row => {
                    const label = row.id.replace('bar-', '');
                    if (!existing.has(label)) row.remove();
                });
            }
        }

        /* =================== Intro Flow =================== */
        window.addEventListener("load", () => {
            speak(welcomeText, () => {
                document.body.classList.add("bg-white");
                document.getElementById("centerNumber").classList.add("hide");
                const img = document.getElementById("gameImg");
                img.style.display = "block"; img.classList.remove("to-left");
                speak(afterText, () => {
                    const mask = document.getElementById("mask"); mask.classList.add("show");
                    setTimeout(async () => {
                        mask.classList.remove("show");
                        document.getElementById("splitContainer").style.display = "flex";
                        img.style.display = "none";
                        startCameraAndWS();

                        await ensureVideoReady(document.getElementById("video"));
                        initPoseModel();
                        initPoseMiniOverlay();

                        setInterval(() => renderBars(false), 200);
                    }, 700);
                });
            });
        });

        /* =================== Util =================== */
        function ensureVideoReady(video) {
            return new Promise((resolve) => {
                const ready = () => video.videoWidth > 0 && video.videoHeight > 0;
                if (video.readyState >= 2 && ready()) return resolve();
                let tries = 0;
                const tick = setInterval(() => { if (ready() || ++tries > 200) { clearInterval(tick); resolve(); } }, 25);
                const onCanPlay = () => { if (ready()) { video.removeEventListener('canplay', onCanPlay); clearInterval(tick); resolve(); } };
                video.addEventListener('canplay', onCanPlay);
            });
        }

        /* =================== Camera + WS + Draw =================== */
        function startCameraAndWS() {
            const video = document.getElementById('video');
            const overlay = document.getElementById('overlay');
            const wsStatus = document.getElementById('wsStatus');
            const wsDot = document.getElementById('wsDot');
            const camInfo = document.getElementById('camInfo');
            const sendFpsEl = document.getElementById('sendFps');
            const recvFpsEl = document.getElementById('recvFps');
            const latEl = document.getElementById('lat');

            let ws; let streaming = false;
            let lastSend = 0; let sendCount = 0, recvCount = 0; let lastLatency = null; let sendingNow = false;

            setInterval(() => {
                sendFpsEl.textContent = sendCount; sendCount = 0;
                recvFpsEl.textContent = recvCount; recvCount = 0;
                latEl.textContent = (lastLatency != null ? Math.round(lastLatency) : '—');
            }, 1000);

            async function openCamera() {
                const constraints = { audio: false, video: { facingMode: 'environment', width: { ideal: 1920 }, height: { ideal: 1080 }, frameRate: { ideal: 30, max: 60 } } };
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;
                const t = stream.getVideoTracks()[0]; const s = t.getSettings ? t.getSettings() : {};
                camInfo.textContent = `${s.width || '?'}×${s.height || '?'} @ ${s.frameRate || '?'}fps`;
                await video.play();
                resizeOverlay();
            }

            function resizeOverlay() {
                overlay.style.left = '0'; overlay.style.top = '0';
                overlay.style.width = '100%'; overlay.style.height = '100%';
                const dpr = Math.max(1, window.devicePixelRatio || 1);
                const cssW = overlay.clientWidth, cssH = overlay.clientHeight;
                overlay.width = Math.floor(cssW * dpr); overlay.height = Math.floor(cssH * dpr);
                overlay.getContext('2d').setTransform(dpr, 0, 0, dpr, 0, 0);
            }
            window.addEventListener('resize', resizeOverlay);

            const wsURL = (location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host + '/ws3';

            function connectWS() {
                try { ws = new WebSocket(wsURL); }
                catch (e) { wsStatus.textContent = 'WS: error'; wsDot.classList.remove('on'); return; }

                ws.binaryType = 'arraybuffer';
                ws.onopen = () => { wsStatus.textContent = 'WS: connected'; wsDot.classList.add('on'); };
                ws.onclose = () => { wsStatus.textContent = 'WS: disconnected'; wsDot.classList.remove('on'); if (streaming) setTimeout(connectWS, 1200); };
                ws.onerror = () => { wsStatus.textContent = 'WS: error'; wsDot.classList.remove('on'); };
                ws.onmessage = (ev) => {
                    try {
                        const msg = JSON.parse(ev.data);
                        parseServerMessageToBoxes(msg, video);
                        lastLatency = (msg.client_latency_ms != null ? msg.client_latency_ms : msg.t_ms);
                        recvCount++;
                    } catch (e) { console.warn('WS message parse error:', e); }
                };
            }

            const sendCanvas = document.createElement('canvas');
            const sendCtx = sendCanvas.getContext('2d', { willReadFrequently: false });
            function computeSendSize(vw, vh) { if (!vw || !vh) return { w: 640, h: 360 }; const sc = Math.min(1, 768 / vw); return { w: Math.round(vw * sc), h: Math.round(vh * sc) }; }
            function sendOneFrame() {
                if (!ws || ws.readyState !== 1) return;
                if (!video.videoWidth || !video.videoHeight) return;
                if (sendingNow) return;
                const now = performance.now(), interval = 1000 / 20;
                if ((now - lastSend) < interval) return;
                sendingNow = true;
                const { w, h } = computeSendSize(video.videoWidth, video.videoHeight);
                if (sendCanvas.width !== w || sendCanvas.height !== h) { sendCanvas.width = w; sendCanvas.height = h; }
                sendCtx.drawImage(video, 0, 0, w, h);
                sendCanvas.toBlob((blob) => {
                    sendingNow = false; if (!blob) return;
                    lastSend = performance.now();
                    const hdr = new TextEncoder().encode(JSON.stringify({ t0: lastSend }));
                    const hdrLen = new Uint32Array([hdr.byteLength]);
                    const reader = new FileReader();
                    reader.onload = () => {
                        const jpegArr = new Uint8Array(reader.result);
                        const packet = new Uint8Array(4 + hdr.byteLength + jpegArr.byteLength);
                        packet.set(new Uint8Array(hdrLen.buffer), 0); packet.set(hdr, 4); packet.set(jpegArr, 4 + hdr.byteLength);
                        try { ws.send(packet); sendCount++; } catch { }
                    };
                    reader.readAsArrayBuffer(blob);
                }, 'image/jpeg', 0.7);
            }

            function startLoop() {
                if ('requestVideoFrameCallback' in HTMLVideoElement.prototype) {
                    const cb = () => { if (streaming) { sendOneFrame(); video.requestVideoFrameCallback(cb); } };
                    video.requestVideoFrameCallback(cb);
                } else {
                    const id = setInterval(() => { if (!streaming) { clearInterval(id); return; } sendOneFrame(); }, 10);
                }
            }

            function mapBoxToOverlay(b, baseW, baseH, drawW, drawH, offX, offY, mirrored = true) {
                let x = b.x, y = b.y, w = b.w, h = b.h;
                if (mirrored) {
                    x = baseW - (b.x + b.w);
                }
                const kx = drawW / baseW, ky = drawH / baseH;
                return { x: offX + x * kx, y: offY + y * ky, w: w * kx, h: h * ky };
            }

            function drawLabeledBox(ctx, rect, stroke, label, s = 1) {
                ctx.save();
                ctx.strokeStyle = stroke;
                ctx.lineWidth = Math.max(1, 2 / s);
                ctx.beginPath();
                ctx.rect(rect.x, rect.y, rect.w, rect.h);
                ctx.stroke();

                if (label) {
                    ctx.font = `${Math.max(10, 14 / s)}px ui-sans-serif`;
                    const textW = ctx.measureText(label).width + 8;
                    const textH = (18 / s) + 6;
                    ctx.fillStyle = 'rgba(0,0,0,0.45)';
                    ctx.fillRect(rect.x, rect.y - textH, textW, textH);
                    ctx.fillStyle = stroke;
                    ctx.fillText(label, rect.x + 4, rect.y - (6 / s));
                }
                ctx.restore();
            }

            function drawPoseOnOverlay(ctx, pose, baseW, baseH, offX, offY, kx, ky) {
                if (!pose || !pose.keypoints) return;
                const minScore = 0.2;
                const mapPt = (kp) => { const p = kp.position || kp; const x = p.x ?? 0, y = p.y ?? 0; const mx = baseW - x; return { x: offX + mx * kx, y: offY + y * ky, s: kp.score ?? kp.probability ?? 0 }; };
                const EDGES = [['leftShoulder', 'rightShoulder'], ['leftShoulder', 'leftElbow'], ['leftElbow', 'leftWrist'], ['rightShoulder', 'rightElbow'], ['rightElbow', 'rightWrist'], ['leftShoulder', 'leftHip'], ['rightShoulder', 'rightHip'], ['leftHip', 'rightHip'], ['leftHip', 'leftKnee'], ['leftKnee', 'leftAnkle'], ['rightHip', 'rightKnee'], ['rightKnee', 'rightAnkle'], ['nose', 'leftEye'], ['nose', 'rightEye'], ['leftEye', 'leftEar'], ['rightEye', 'rightEar']];
                const byName = {}; for (const kp of pose.keypoints) { const n = kp.part || kp.name || ''; if (n) byName[n] = kp; }
                ctx.save(); ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.strokeStyle = '#00E5FF'; ctx.fillStyle = '#00E5FF'; ctx.lineWidth = 3;
                for (const [a, b] of EDGES) { const ka = byName[a], kb = byName[b]; if (!ka || !kb) continue; const A = mapPt(ka), B = mapPt(kb); if (A.s < 0.2 || B.s < 0.2) continue; ctx.beginPath(); ctx.moveTo(A.x, A.y); ctx.lineTo(B.x, B.y); ctx.stroke(); }
                for (const name in byName) { const P = mapPt(byName[name]); if (P.s < minScore) continue; ctx.beginPath(); ctx.arc(P.x, P.y, 4, 0, Math.PI * 2); ctx.fill(); }
                ctx.restore();
            }

            function drawLoop() {
                const ctx = overlay.getContext('2d');
                const draw = () => {
                    if (!streaming) return;
                    ctx.clearRect(0, 0, overlay.clientWidth, overlay.clientHeight);

                    const vw = video.videoWidth, vh = video.videoHeight;
                    if (!vw || !vh) { requestAnimationFrame(draw); return; }

                    const fitScale = Math.min(overlay.clientWidth / vw, overlay.clientHeight / vh);
                    const drawW = vw * fitScale, drawH = vh * fitScale;
                    const offX = (overlay.clientWidth - drawW) / 2, offY = (overlay.clientHeight - drawH) / 2;

                    const baseW_box = (srcW || vw), baseH_box = (srcH || vh);
                    const s = Math.min(drawW / baseW_box, drawH / baseH_box);

                    for (const b of boxesA) {
                        const mapped = mapBoxToOverlay(b, baseW_box, baseH_box, drawW, drawH, offX, offY, true);
                        const tag = `${b.label || b.class || 'human'} ${b.conf != null ? (b.conf * 100 | 0) : ''}%`;
                        drawLabeledBox(ctx, mapped, '#00FF88', tag, s);
                    }
                    for (const b of boxesB) {
                        const mapped = mapBoxToOverlay(b, baseW_box, baseH_box, drawW, drawH, offX, offY, true);
                        const tag = `${b.label || b.class || 'animal'} ${b.conf != null ? (b.conf * 100 | 0) : ''}%`;
                        drawLabeledBox(ctx, mapped, '#3b82f6', tag, s);
                    }

                    const pairs = pairAnimalsWithHumans(boxesB, boxesA);
                    const nowMs = performance.now();
                    updateCooperationForPairs(pairs, nowMs);

                    ctx.save();
                    ctx.strokeStyle = 'rgba(255,255,255,.55)';
                    ctx.lineWidth = Math.max(1, 2 / s);
                    for (const { animal, human } of pairs) {
                        const am = mapBoxToOverlay(animal, baseW_box, baseH_box, drawW, drawH, offX, offY, true);
                        const hm = mapBoxToOverlay(human, baseW_box, baseH_box, drawW, drawH, offX, offY, true);
                        const acx = am.x + am.w / 2, acy = am.y + am.h / 2;
                        const hcx = hm.x + hm.w / 2;
                        ctx.beginPath();
                        ctx.moveTo(acx, acy);
                        ctx.lineTo(hcx, hm.y);
                        ctx.stroke();
                    }
                    ctx.restore();

                    if (DRAW_POSE_ON_MAIN) {
                        const kx_pose = drawW / vw, ky_pose = drawH / vh;
                        drawPoseOnOverlay(ctx, window.__latestPose, vw, vh, offX, offY, kx_pose, ky_pose);
                    }

                    requestAnimationFrame(draw);
                };
                requestAnimationFrame(draw);
            }

            openCamera().then(() => { connectWS(); streaming = true; startLoop(); drawLoop(); });

            /* =======================================================================
               ปุ่ม “เสร็จสิ้น” → สรุปคะแนน → บันทึกด้วย database.js → ไปหน้าถัดไป
               *** NOTE *** หน้านี้เป็นด่าน 1 → ใช้ saveGame1Result เท่านั้น
               ถ้าเป็นหน้า game2.html ให้เปลี่ยนเพียงชื่อฟังก์ชันเป็น saveGame2Result
               (ส่วนอื่นไม่ต้องแก้)
            ======================================================================= */
            document.getElementById('nextBtn')?.addEventListener('click', async (e) => {
                e.preventDefault();
                const btn = e.currentTarget;
                const href = btn.getAttribute('href');
                btn.textContent = 'กำลังบันทึก…'; btn.style.opacity = .85; btn.style.pointerEvents = 'none';

                // 1) ล็อกผลเฉลี่ยต่อสัตว์ (ถ้าไม่มี samples ใช้ค่าสุดท้าย)
                const finalMap = finalizeCooperation();   // รูปแบบ: { [animalId]: scoreInt0..100 }
                renderBars(true);
                try { sessionStorage.setItem('finalCoop', JSON.stringify(finalMap)); } catch { }

                try {
                    // 2) เรียก database.js → ใช้ฟังก์ชันของ "ด่านนี้"
                    //    *** สำหรับหน้าอื่น เปลี่ยนชื่อฟังก์ชันให้ตรงด่าน (saveGame2Result/3/4) ***
                    const { saveGame1Result } = await import('./database.js');

                    if (typeof saveGame1Result !== 'function') {
                        throw new Error('saveGame1Result not found in database.js');
                    }

                    // ระบุผู้เล่น (ถ้าไม่ได้ตั้งไว้ที่อื่น ให้ใช้ 'anonymous')
                    const userId = window.__currentUserId || sessionStorage.getItem('currentUserId') || 'anonymous';

                    // ข้อมูลเสริมสำหรับบันทึก (จะ merge ในเอกสาร)
                    const extra = {
                        source: 'game1',
                        page: location.pathname,
                        ts: Date.now()
                        // คุณสามารถเพิ่ม animalName/animalImage ฯลฯ ตรงนี้ได้ตามต้องการ
                    };

                    // 3) บันทึกทุกตัวที่มีคะแนน
                    // database.js จะ upsert ด้วย doc id คงที่ (userId__animalId) → ไม่สร้างเอกสารซ้ำ
                    // 3) บันทึกทุกตัวที่มีคะแนน
                    const tasks = Object.entries(finalMap).map(([animalId, score]) =>
                        saveGame1Result({ userId, animalId, score, extra })
                    );

                    // ✨ ส่งค่าไปที่ app.py ด้วย
                    try {
                        await fetch("http://127.0.0.1:8004/set_score", {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({ score: finalMap })
                        });
                        console.log("ส่ง score ไปยัง app.py สำเร็จ");
                    } catch (err) {
                        console.error("ส่ง score ไป app.py ไม่สำเร็จ:", err);
                    }

                    await Promise.all(tasks);

                    // 4) ไปหน้าถัดไป
                    window.location.href = href;
                } catch (err) {
                    console.error('Save to Firestore failed:', err);
                    alert('บันทึกผลไม่สำเร็จ กรุณาลองอีกครั้ง');
                    btn.textContent = 'เสร็จสิ้น →'; btn.style.opacity = 1; btn.style.pointerEvents = '';
                }
            });
        }

        /* =================== TM Pose =================== */
        const TM_URL = "https://teachablemachine.withgoogle.com/models/E9Gz4yAP4/";
        let tmModel, tmLabelContainer;
        async function initPoseModel() {
            const modelURL = TM_URL + "model.json";
            const metadataURL = TM_URL + "metadata.json";
            tmModel = await tmPose.load(modelURL, metadataURL);

            const video = document.getElementById("video");
            tmLabelContainer = document.getElementById("pose-label-container");
            tmLabelContainer.innerHTML = "";
            for (let i = 0; i < tmModel.getTotalClasses(); i++) tmLabelContainer.appendChild(document.createElement("div"));

            const loop = async () => {
                const { pose, posenetOutput } = await tmModel.estimatePose(video);
                const prediction = await tmModel.predict(posenetOutput);

                for (let i = 0; i < prediction.length; i++) {
                    tmLabelContainer.childNodes[i].innerHTML = prediction[i].className + ": " + prediction[i].probability.toFixed(2);
                }
                window.__latestPose = pose;
                let top = prediction[0]; for (const p of prediction) if (p.probability > top.probability) top = p;
                window.__latestPoseTop = { name: top.className, prob: top.probability };

                const badge = document.getElementById('tmBadge');
                if (badge && top) badge.textContent = `${top.className} ${(top.probability * 100).toFixed(0)}%`;

                requestAnimationFrame(loop);
            };
            requestAnimationFrame(loop);
        }

        /* =================== Mini Pose Canvas =================== */
        function initPoseMiniOverlay() {
            const mini = document.getElementById("tmMini");
            const canvas = document.getElementById("tmMiniCanvas");
            const ctx = canvas.getContext("2d");
            const video = document.getElementById("video");

            const resize = () => {
                const dpr = Math.max(1, window.devicePixelRatio || 1);
                const rect = mini.getBoundingClientRect();
                const cssW = Math.max(1, rect.width);
                const cssH = Math.max(1, rect.height);
                canvas.width = Math.floor(cssW * dpr);
                canvas.height = Math.floor(cssH * dpr);
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            };
            resize();
            window.addEventListener("resize", resize);
            new ResizeObserver(resize).observe(mini);

            const render = () => {
                const cw = mini.clientWidth, ch = mini.clientHeight;
                ctx.clearRect(0, 0, cw, ch);

                const vw = video.videoWidth, vh = video.videoHeight;
                if (vw && vh && cw > 0 && ch > 0) {
                    const scale = Math.min(cw / vw, ch / vh);
                    const drawW = vw * scale, drawH = vh * scale;
                    const offX = (cw - drawW) / 2, offY = (ch - drawH) / 2;

                    ctx.save();
                    ctx.translate(offX + drawW, offY);
                    ctx.scale(-scale, scale);
                    ctx.drawImage(video, 0, 0, vw, vh);
                    ctx.restore();

                    const pose = window.__latestPose;
                    if (pose && pose.keypoints) {
                        ctx.save();
                        ctx.translate(offX, offY);
                        ctx.scale(scale, scale);
                        ctx.translate(vw, 0); ctx.scale(-1, 1);
                        const minScore = 0.2;
                        tmPose.drawKeypoints(pose.keypoints, minScore, ctx);
                        tmPose.drawSkeleton(pose.keypoints, minScore, ctx);
                        ctx.restore();
                    }
                }
                requestAnimationFrame(render);
            };
            requestAnimationFrame(render);
        }
    </script>
</body>

</html>