<!DOCTYPE html>
<html lang="th">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>NON — Dual Model Realtime</title>
    <style>
        html,
        body {
            margin: 0;
            height: 100%;
            background: #000;
        }

        #wrap {
            position: fixed;
            inset: 0;
        }

        video,
        canvas {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .hint {
            position: fixed;
            left: 50%;
            bottom: 20px;
            transform: translateX(-50%);
            color: #fff;
            font: 14px/1.4 system-ui, Arial;
            opacity: .9;
            background: rgba(0, 0, 0, .35);
            padding: 8px 12px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, .25);
        }

        .status {
            position: fixed;
            top: 12px;
            left: 12px;
            color: #fff;
            font: 12px/1.2 system-ui, Arial;
            background: rgba(0, 0, 0, .35);
            padding: 6px 10px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, .2);
        }
    </style>
</head>

<body>
    <div id="wrap">
        <video id="cam" autoplay playsinline muted></video>
        <canvas id="overlay"></canvas>
    </div>
    <div class="hint">กำลังเปิดกล้อง… หากไม่ขึ้น ให้ตรวจสอบสิทธิ์กล้อง</div>
    <div class="status" id="status">WS: disconnected</div>

    <script>
        const videoEl = document.getElementById("cam");
        const canvas = document.getElementById("overlay");
        const ctx = canvas.getContext("2d");
        const statusEl = document.getElementById("status");

        // ชี้ไปที่ backend
        const WS_URL = "ws://localhost:8000/ws";

        const SEND_INTERVAL_MS = 100;  // 10 FPS
        const JPEG_QUALITY = 0.6;

        let ws, sending = false;
        let det_animal = [], det_hand = [];

        (async () => {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: "user" }, audio: false
                });
                videoEl.srcObject = stream;
                await new Promise(r => videoEl.onloadedmetadata = r);
                resizeCanvas();
                document.querySelector(".hint").style.display = "none";

                connectWS();
                startSendingLoop();
                drawLoop();
            } catch (e) {
                alert("ไม่สามารถเข้าถึงกล้องได้: " + e.message);
            }
        })();

        function resizeCanvas() {
            canvas.width = videoEl.videoWidth || canvas.clientWidth;
            canvas.height = videoEl.videoHeight || canvas.clientHeight;
        }
        window.addEventListener("resize", resizeCanvas);

        function connectWS() {
            ws = new WebSocket(WS_URL);
            ws.binaryType = "arraybuffer";

            ws.onopen = () => { statusEl.textContent = "WS: connected"; };
            ws.onclose = () => { statusEl.textContent = "WS: disconnected (retrying...)"; setTimeout(connectWS, 1500); };
            ws.onerror = () => { statusEl.textContent = "WS: error"; };
            ws.onmessage = (ev) => {
                try {
                    const msg = JSON.parse(ev.data);
                    console.log("[WS RX]", msg);  // แสดงผลใน console

                    if (msg.error) return;
                    if (msg.mode === "dual" && Array.isArray(msg.models)) {
                        const mAnimal = msg.models.find(m => m.name === "animal_detection");
                        const mHand = msg.models.find(m => m.name === "hand_detection");
                        det_animal = mAnimal?.detections || [];
                        det_hand = mHand?.detections || [];
                    }
                } catch (_) { }
            };
        }

        function drawLoop() {
            requestAnimationFrame(drawLoop);
            if (!videoEl.videoWidth) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const sx = canvas.width / videoEl.videoWidth;
            const sy = canvas.height / videoEl.videoHeight;

            drawDetections(det_animal, "#00FF88", sx, sy); // เขียว
            drawDetections(det_hand, "#C000FF", sx, sy); // ม่วง
        }

        function drawDetections(arr, stroke, sx, sy) {
            for (const d of arr) {
                const { x, y, w, h, conf, label } = d;
                const x1 = (x - w / 2) * sx, y1 = (y - h / 2) * sy;
                const x2 = (x + w / 2) * sx, y2 = (y + h / 2) * sy;

                ctx.lineWidth = 3;
                ctx.strokeStyle = stroke;
                ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);

                const txt = `${label} ${(conf * 100).toFixed(1)}%`;
                ctx.font = "16px system-ui, Arial";
                ctx.fillStyle = "rgba(0,0,0,0.6)";
                const m = ctx.measureText(txt), bw = m.width + 12, bh = 22;
                ctx.fillRect(x1, Math.max(0, y1 - bh), bw, bh);
                ctx.fillStyle = "#FFF";
                ctx.fillText(txt, x1 + 6, Math.max(16, y1 - 6));
            }
        }

        function startSendingLoop() {
            const off = document.createElement("canvas");
            const octx = off.getContext("2d");

            setInterval(async () => {
                if (!ws || ws.readyState !== WebSocket.OPEN) return;
                if (sending) return;
                if (!videoEl.videoWidth) return;

                off.width = videoEl.videoWidth;
                off.height = videoEl.videoHeight;
                octx.drawImage(videoEl, 0, 0, off.width, off.height);

                sending = true;
                try {
                    const blob = await new Promise(res => off.toBlob(res, "image/jpeg", JPEG_QUALITY));
                    if (!blob) return;
                    const arrBuf = await blob.arrayBuffer();
                    ws.send(arrBuf);
                } finally { sending = false; }
            }, SEND_INTERVAL_MS);
        }
    </script>
</body>

</html>