<!doctype html>
<html lang="th">

<head>
    <meta charset="utf-8" />
    <title>เกมรู้จักใบหน้า - Transition + Pose Model</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial;
            background: #7172DC;
            transition: background .5s;
            overflow: hidden;
        }

        body.bg-white {
            background: #fff !important;
        }

        .center-img {
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            max-width: min(50vw, 600px);
            width: 100%;
            height: auto;
            display: block;
            animation: fadein .7s;
            z-index: 10;
            transition: left .7s, top .7s, transform .7s;
        }

        .center-img.to-left {
            left: 25%;
            top: 50%;
            transform: translate(-50%, -50%);
        }

        .split-container {
            position: fixed;
            inset: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            transition: background .5s;
        }

        .split-left,
        .split-right {
            width: 50vw;
            height: 100vh;
            position: relative;
            transition: box-shadow .5s;
        }

        .split-left {
            background: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 32px 0 rgba(113, 114, 220, .08);
            z-index: 2;
        }

        .split-right {
            background: #111;
            box-shadow: 0 0 32px 0 rgba(113, 114, 220, .08);
            z-index: 1;
            overflow: hidden;
        }

        @keyframes fadein {
            from {
                opacity: 0;
                transform: scale(.8)
            }

            to {
                opacity: 1;
                transform: scale(1)
            }
        }

        .center-number {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(60px, 12vw, 300px);
            font-weight: 800;
            color: #fff;
            z-index: 20;
            pointer-events: none;
            user-select: none;
            text-shadow: 0 2px 8px rgba(0, 0, 0, .3);
            transition: opacity .5s;
        }

        .center-number.hide {
            opacity: 0;
        }

        .transition-mask {
            position: fixed;
            inset: 0;
            background: #fff;
            z-index: 99;
            pointer-events: none;
            opacity: 0;
            transition: opacity .7s;
        }

        .transition-mask.show {
            opacity: 1;
        }

        .stage {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #111;
        }

        video,
        canvas {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
        }

        video {
            object-fit: contain;
            background: #111;
            transform: scaleX(-1);
        }

        #overlay {
            pointer-events: none;
            z-index: 5;
        }

        .hud {
            position: absolute;
            left: 8px;
            bottom: 5px;
            display: flex;
            gap: 8px;
            align-items: center;
            background: rgba(0, 0, 0, .30);
            padding: 6px 10px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, .08);
            font-size: .8vw;
            line-height: 1.2;
            height: 1.8vw;
            z-index: 10;
        }

        .badge {
            padding: 2px 6px;
            border-radius: 6px;
            background: rgba(255, 255, 255, .04);
            border: 1px solid rgba(255, 255, 255, .08)
        }

        .dot {
            width: 1vw;
            height: 1vw;
            border-radius: 50%;
            display: inline-block;
            margin-right: 6px;
            background: #b33
        }

        .dot.on {
            background: #29c26f
        }

        .next-btn {
            position: absolute;
            right: 24px;
            bottom: 24px;
            background: #0a502f;
            color: #fff;
            text-decoration: none;
            font-weight: 700;
            font-size: 1.2vw;
            padding: 12px 18px;
            border-radius: 10px;
            border: 1px solid #169b1a;
            transition: transform .1s ease, filter .1s ease;
            z-index: 20
        }

        .next-btn:hover {
            transform: translateY(-1px);
            filter: saturate(1.05)
        }

        #pose-label-container {
            position: absolute;
            top: 12px;
            right: 24px;
            z-index: 30;
            background: rgba(255, 255, 255, .12);
            border-radius: 12px;
            padding: 12px 18px;
            color: #fff;
            font-size: 1.1em;
            font-weight: 600;
            box-shadow: 0 2px 12px rgba(0, 0, 0, .08)
        }

        .tm-mini {
            position: absolute;
            top: 12px;
            right: 12px;
            width: 25%;
            aspect-ratio: 4/3;
            background: rgba(0, 0, 0, .32);
            border: 1px solid rgba(255, 255, 255, .18);
            border-radius: 14px;
            overflow: hidden;
            z-index: 40;
            backdrop-filter: blur(4px);
            box-shadow: 0 8px 24px rgba(0, 0, 0, .25);
            pointer-events: none
        }

        .tm-mini canvas {
            width: 100%;
            height: 100%;
            display: block
        }

        .tm-badge {
            position: absolute;
            left: 10px;
            top: 10px;
            z-index: 41;
            background: rgba(0, 0, 0, .55);
            color: #fff;
            font-weight: 700;
            font-size: 12px;
            padding: 6px 10px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, .1);
            pointer-events: none
        }

        /* ====== แผงกราฟคะแนนความร่วมมือ (ด้านขวา) ====== */
        .results-panel {
            position: absolute;
            top: 50%;
            right: 12px;
            transform: translateY(-50%);
            width: 22%;
            max-width: 360px;
            min-width: 220px;
            background: rgba(255, 255, 255, .06);
            border: 1px solid rgba(255, 255, 255, .18);
            border-radius: 14px;
            padding: 12px;
            color: #fff;
            z-index: 45;
            backdrop-filter: blur(4px);
            box-shadow: 0 8px 24px rgba(0, 0, 0, .25);
        }

        .results-title {
            font-weight: 800;
            margin: 0 0 8px 0;
            font-size: 14px;
            opacity: .95;
        }

        .bar-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 8px 0;
        }

        .bar-label {
            width: 38%;
            font-size: 12px;
            opacity: .9;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .bar {
            flex: 1;
            height: 14px;
            background: rgba(255, 255, 255, .12);
            border-radius: 999px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, .18);
        }

        .bar>.fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #60a5fa, #22c55e);
            transition: width .25s ease-out;
        }

        .bar-val {
            width: 42px;
            text-align: right;
            font-size: 12px;
            opacity: .9;
        }

        @media (max-width:900px) {
            .split-container {
                flex-direction: column
            }

            .split-right {
                width: 100vw;
                height: 50vh
            }

            .next-btn {
                font-size: 3vw
            }

            .hud {
                font-size: 2vw;
                height: 4vw
            }

            .tm-mini {
                width: 38%
            }

            .results-panel {
                width: 44%;
                right: 8px;
                top: auto;
                bottom: 8px;
                transform: none;
            }
        }
    </style>
</head>

<body>
    <div class="center-number" id="centerNumber">1</div>

    <!-- ใช้ path ของคุณตามจริงได้เลย (แนะนำ path relative แทน absolute) -->
    <img id="gameImg"
        src="/Users/sutinan/Desktop/Project/NON-AUTOS-MINE(Overall)/my-website/src/image/game/image 67.png"
        alt="เกมรู้จักใบหน้า" class="center-img" style="display:none;" />

    <div class="transition-mask" id="mask"></div>

    <div class="split-container" id="splitContainer" style="display:none;">
        <div class="split-left">
            <img src="/Users/sutinan/Desktop/Project/NON-AUTOS-MINE(Overall)/my-website/src/image/game/image 67.png"
                alt="เกมรู้จักใบหน้า" class="center-img to-left" />
        </div>
        <div class="split-right">
            <div class="stage">
                <video id="video" autoplay playsinline muted></video>
                <canvas id="overlay"></canvas>
                <canvas id="pose-canvas"></canvas>
                <div id="pose-label-container"></div>

                <!-- Mini TM Pose -->
                <div id="tmMini" class="tm-mini">
                    <span id="tmBadge" class="tm-badge">Pose</span>
                    <canvas id="tmMiniCanvas"></canvas>
                </div>

                <!-- ===== พาเนลกราฟคะแนนความร่วมมือ ===== -->
                <div class="results-panel" id="resultsPanel">
                    <p class="results-title" id="resultsTitle">คะแนนความร่วมมือ (สด)</p>
                    <div id="bars"></div>
                </div>
            </div>

            <div class="hud">
                <span class="badge"><span id="wsDot" class="dot"></span><span id="wsStatus">WS:
                        disconnected</span></span>
                <span class="badge">Cam: <span id="camInfo">—</span></span>
                <span class="badge">Tx: <span id="sendFps">0</span> fps</span>
                <span class="badge">Rx: <span id="recvFps">0</span> fps</span>
                <span class="badge">Latency: <span id="lat">—</span> ms</span>
            </div>

            <a href="checkgame1.html" id="nextBtn" class="next-btn">เสร็จสิ้น →</a>
        </div>
    </div>

    <script type="module">
        // ===== Firebase CDN Modular v9 =====
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.14.1/firebase-app.js";
        import { getFirestore, collection, addDoc, serverTimestamp } from "https://www.gstatic.com/firebasejs/10.14.1/firebase-firestore.js";

        // ---- Config ----
        const firebaseConfig = {
            apiKey: "AIzaSyAafwo9zrpeiTu11qpafsyOe6lN1yZsexU",
            authDomain: "nonwebsite-5077e.firebaseapp.com",
            databaseURL: "https://nonwebsite-5077e-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "nonwebsite-5077e",
            storageBucket: "nonwebsite-5077e.appspot.com",
            messagingSenderId: "853304554751",
            appId: "1:853304554751:web:a314f134e9287ae80d48ca",
            measurementId: "G-S7T20G4D3J"
        };

        // ---- Init ----
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        // ---- ฟังก์ชันบันทึกผลเกม ----
        export async function saveGame1Result({ userId, animalId, score, extra = {} }) {
            const payload = {
                userId: userId || "anonymous",
                Animal_ID: animalId ?? "unknown",
                game1: typeof score === "number" ? Math.max(0, Math.min(100, Math.round(score))) : 0,
                createdAt: serverTimestamp(),
                ...extra,
            };
            const ref = await addDoc(collection(db, "game1_results"), payload);
            console.log("บันทึกสำเร็จ doc id:", ref.id);
            return ref.id;
        }

        // (คงโค้ดตัวอย่างเดิมไว้ แต่กัน error ถ้าไม่มีปุ่ม saveBtn) // *** ADDED (safety, ไม่เปลี่ยนพฤติกรรมหลัก)
        const __tmpSaveBtn = document.getElementById("saveBtn");
        if (__tmpSaveBtn) {
            __tmpSaveBtn.addEventListener("click", async () => {
                try {
                    const docId = await saveGame1Result({
                        userId: "kid001",
                        animalId: "lion",
                        score: 85,
                        extra: { source: "game1", page: location.pathname }
                    });
                    alert("บันทึกผลสำเร็จ! id=" + docId);
                } catch (err) {
                    console.error("บันทึกไม่สำเร็จ:", err);
                    alert("บันทึกไม่สำเร็จ");
                }
            });
        }
    </script>

    <!-- TM Pose libs -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.3.1/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@teachablemachine/pose@0.8/dist/teachablemachine-pose.min.js"></script>

    <script>
        const DRAW_POSE_ON_MAIN = false;

        /* =================== TTS =================== */
        function speak(text, cb) {
            if (!("speechSynthesis" in window)) return cb && cb();
            const u = new SpeechSynthesisUtterance(text);
            u.lang = "th-TH"; u.rate = 0.8; u.pitch = 1.0;
            u.onend = () => cb && cb(); u.onerror = () => cb && cb();
            speechSynthesis.cancel(); speechSynthesis.speak(u);
        }
        const welcomeText = "สวัสดีครับวันนี้เรามาเล่นเกม 'รู้จักใบหน้า' กันดีกว่านะครับเด็กๆ เริ่มที่ด่านที่ 1 ครับ";
        const afterText = "เด็กดูภาพแล้วบอกว่ารูปนี้เป็นอารมณ์แบบไหนครับ ถ้าเข้าใจแล้วก็เริ่มต่อเป็นหน้าตาตามที่แสดงอยู่ได้เลยครับ";

        /* =================== Globals =================== */
        let boxesA = []; // human
        let boxesB = []; // animal
        let srcW = 0, srcH = 0;

        window.__latestPose = null;
        window.__latestPoseTop = null;

        const CoopState = {};
        const COLOR_POOL = ['#22c55e', '#60a5fa', '#f59e0b', '#f43f5e', '#a78bfa', '#10b981', '#ef4444', '#14b8a6', '#eab308', '#8b5cf6'];
        let colorIdx = 0;

        const SCORE_CFG = {
            maxHumanSpeedGood: 0.020,
            maxAnimalSpeedGood: 0.015,
            minPresenceMs: 1500,
            wHumanSteady: 0.45,
            wAnimalStable: 0.25,
            wPose: 0.30,
            sampleWindowMs: 5000
        };

        function centerOf(b) { return { cx: b.x + b.w / 2, cy: b.y + b.h / 2 }; }
        function diagOf(w, h) { return Math.hypot(w, h) || 1; }
        function clamp01(x) { return Math.max(0, Math.min(1, x)); }
        function clamp100(x) { return Math.max(0, Math.min(100, x)); }

        /* =================== จับคู่แบบเดิม (สำหรับ fallback) =================== */
        function isAnimalAboveHuman(an, hu) {
            const anBottom = an.y + an.h, huTop = hu.y;
            const xOverlap = !(an.x + an.w < hu.x || an.x > hu.x + hu.w);
            return (anBottom <= huTop) && xOverlap;
        }

        /* =================== Utilities สำหรับ Overlap / IoU =================== */
        // *** ADDED
        function rectCenter(b) { return { x: b.x + b.w / 2, y: b.y + b.h / 2 }; } // *** ADDED
        function rectIntersectArea(a, b) { // *** ADDED
            const x1 = Math.max(a.x, b.x);
            const y1 = Math.max(a.y, b.y);
            const x2 = Math.min(a.x + a.w, b.x + b.w);
            const y2 = Math.min(a.y + a.h, b.y + b.h);
            const w = Math.max(0, x2 - x1);
            const h = Math.max(0, y2 - y1);
            return w * h;
        }
        function rectIoU(a, b) { // *** ADDED
            const inter = rectIntersectArea(a, b);
            const union = a.w * a.h + b.w * b.h - inter;
            return union > 0 ? inter / union : 0;
        }

        /* =================== Pairing ใหม่: รองรับ "ทับกันเล็กน้อยก็ถือว่าคู่" =================== */
        // *** ADDED (แทนที่ pairAnimalsWithHumans เดิม)
        function pairAnimalsWithHumans(animals, humans) {
            const pairs = [];
            for (const an of animals) {
                const label = String(an.label || an.class || an.src || 'animal');

                // 1) priority: กล่องทับกัน → เอาพื้นที่ทับซ้อนมากที่สุด
                const overlapCands = humans
                    .map(h => ({ human: h, area: rectIntersectArea(an, h), iou: rectIoU(an, h) }))
                    .filter(o => o.area > 0);

                if (overlapCands.length > 0) {
                    overlapCands.sort((a, b) => (b.area - a.area) || (b.iou - a.iou));
                    pairs.push({ label, animal: an, human: overlapCands[0].human });
                    continue;
                }

                // 2) fallback เดิม: สัตว์อยู่เหนือคนและใกล้สุดในแนวตั้ง
                let bestAbove = null, bestDy = Infinity;
                for (const hu of humans) {
                    if (!isAnimalAboveHuman(an, hu)) continue;
                    const dy = Math.max(0, hu.y - (an.y + an.h));
                    if (dy < bestDy) { bestDy = dy; bestAbove = hu; }
                }
                if (bestAbove) {
                    pairs.push({ label, animal: an, human: bestAbove });
                    continue;
                }

                // 3) ทางเลือกสุดท้าย: คนที่ใกล้ศูนย์กลางที่สุด
                const ac = rectCenter(an);
                let bestNear = null, bestDist = Infinity;
                for (const hu of humans) {
                    const hc = rectCenter(hu);
                    const d = Math.hypot(ac.x - hc.x, ac.y - hc.y);
                    if (d < bestDist) { bestDist = d; bestNear = hu; }
                }
                if (bestNear) pairs.push({ label, animal: an, human: bestNear });
            }
            return pairs;
        }

        /* =================== แปลงกล่อง/สเกลตามขนาดวิดีโอจริง =================== */
        function parseServerMessageToBoxes(msg, video) {
            const vw = video.videoWidth || 1920;
            const vh = video.videoHeight || 1080;

            let a = msg.boxesA || msg.boxes_human || msg.humans || [];
            let b = msg.boxesB || msg.boxes_animal || msg.animals || [];

            if ((!a.length && !b.length) && Array.isArray(msg.detections)) {
                const low = s => (s || '').toLowerCase();
                a = msg.detections.filter(o => low(o.class || o.label) === 'human' || low(o.src || '').includes('human'));
                b = msg.detections.filter(o => low(o.class || o.label) === 'animal' || low(o.src || '').includes('animal'));
            }
            if ((!a.length && !b.length) && Array.isArray(msg.boxes)) {
                const all = msg.boxes, low = s => (s || '').toLowerCase();
                a = all.filter(bb => low(bb.class || bb.label || bb.src).includes('human'));
                b = all.filter(bb => low(bb.class || bb.label || bb.src).includes('animal'));
                if (!a.length && !b.length) a = all;
            }

            if (typeof msg.w === 'number') srcW = msg.w;
            if (typeof msg.h === 'number') srcH = msg.h;

            const BW = srcW || vw, BH = srcH || vh;
            const toPixels = (bb) => {
                if (!bb) return bb;
                const norm = (bb.w <= 1.5 && bb.h <= 1.5);
                return norm ? { ...bb, x: bb.x * BW, y: bb.y * BH, w: bb.w * BW, h: bb.h * BH } : bb;
            };
            boxesA = (a || []).map(toPixels);
            boxesB = (b || []).map(toPixels);
        }

        function updateCooperationForPairs(pairs, nowMs) {
            const W = srcW || 1920, H = srcH || 1080, diag = diagOf(W, H);
            const poseProb = (window.__latestPoseTop?.prob || 0);

            for (const { label, animal, human } of pairs) {
                if (!CoopState[label]) {
                    CoopState[label] = {
                        color: COLOR_POOL[colorIdx++ % COLOR_POOL.length],
                        lastHumanCXN: null, lastHumanCYN: null,
                        lastAnCXN: null, lastAnCYN: null,
                        lastT: nowMs,
                        speedHumanEma: 0, speedAnimalEma: 0,
                        presentStreakMs: 0,
                        scoreNow: 0,
                        samples5s: [],
                        lastBucketTs: nowMs
                    };
                }
                const st = CoopState[label];

                const hc = centerOf(human), ac = centerOf(animal);
                const hxn = hc.cx / W, hyn = hc.cy / H;
                const axn = ac.cx / W, ayn = ac.cy / H;

                const dt = Math.max(1, nowMs - (st.lastT || nowMs)) / 1000.0;

                let vH = 0, vA = 0;
                if (st.lastHumanCXN != null) {
                    const dh = Math.hypot((st.lastHumanCXN - hxn) * W, (st.lastHumanCYN - hyn) * H) / diag;
                    vH = dh / dt;
                }
                if (st.lastAnCXN != null) {
                    const da = Math.hypot((st.lastAnCXN - axn) * W, (st.lastAnCYN - ayn) * H) / diag;
                    vA = da / dt;
                }

                st.speedHumanEma = (st.lastHumanCXN == null) ? vH : (0.35 * vH + 0.65 * st.speedHumanEma);
                st.speedAnimalEma = (st.lastAnCXN == null) ? vA : (0.35 * vA + 0.65 * st.speedAnimalEma);

                st.lastHumanCXN = hxn; st.lastHumanCYN = hyn;
                st.lastAnCXN = axn; st.lastAnCYN = ayn;
                st.lastT = nowMs;

                st.presentStreakMs += (dt * 1000);

                const humanSteady = clamp100(100 * (1 - (st.speedHumanEma / SCORE_CFG.maxHumanSpeedGood)));
                const animalStableRaw = clamp100(100 * (1 - (st.speedAnimalEma / SCORE_CFG.maxAnimalSpeedGood)));
                const presenceFactor = clamp01(st.presentStreakMs / SCORE_CFG.minPresenceMs);
                const animalStable = animalStableRaw * presenceFactor;
                const posePct = clamp100(poseProb * 100);

                const score = (SCORE_CFG.wHumanSteady * humanSteady) +
                    (SCORE_CFG.wAnimalStable * animalStable) +
                    (SCORE_CFG.wPose * posePct);
                st.scoreNow = clamp100(score);
            }

            const alive = new Set(pairs.map(p => p.label));
            for (const [label, st] of Object.entries(CoopState)) {
                if (!alive.has(label)) st.presentStreakMs = 0;
            }

            window.__coopByAnimal = Object.fromEntries(
                Object.entries(CoopState).map(([label, st]) => [label, st.scoreNow])
            );
        }

        function finalizeCooperation() {
            const result = {};
            for (const [label, st] of Object.entries(CoopState)) {
                let arr = st.samples5s.slice();
                if (arr.length === 0) arr = [clamp100(st.scoreNow || 0)];
                const avg = clamp100(arr.reduce((a, b) => a + b, 0) / arr.length);
                result[label] = Math.round(avg);
            }
            window.__finalCoopPerAnimal = result;
            try { localStorage.setItem('finalCoop', JSON.stringify({ ts: Date.now(), data: result })); } catch { }
            return result;
        }

        /* ===== กราฟคะแนนความร่วมมือ (ผลสด) ===== */
        function renderBars(showFinal = false) {
            const titleEl = document.getElementById('resultsTitle');
            const barsEl = document.getElementById('bars');
            if (!barsEl) return;

            let dataEntries = [];

            if (showFinal && window.__finalCoopPerAnimal) {
                titleEl.textContent = 'ผลเฉลี่ย (ล็อกก่อนย้ายหน้า)';
                dataEntries = Object.entries(window.__finalCoopPerAnimal)
                    .map(([label, score]) => ({ label, score, color: CoopState[label]?.color || '#60a5fa' }));
            } else {
                titleEl.textContent = 'คะแนนความร่วมมือ (สด)';
                dataEntries = Object.entries(CoopState)
                    .map(([label, st]) => ({ label, score: Math.round(st.scoreNow || 0), color: st.color || '#60a5fa' }));
            }

            const existing = new Set();
            for (const { label, score, color } of dataEntries.sort((a, b) => b.score - a.score)) {
                existing.add(label);
                let row = document.getElementById('bar-' + label);
                if (!row) {
                    row = document.createElement('div');
                    row.className = 'bar-row';
                    row.id = 'bar-' + label;
                    row.innerHTML = `
            <div class="bar-label"></div>
            <div class="bar"><div class="fill"></div></div>
            <div class="bar-val">0%</div>
          `;
                    barsEl.appendChild(row);
                }
                row.querySelector('.bar-label').textContent = label;
                const fill = row.querySelector('.fill');
                fill.style.width = `${score}%`;
                fill.style.background = `linear-gradient(90deg, ${color}, #22c55e)`;
                row.querySelector('.bar-val').textContent = `${score}%`;
            }

            if (!showFinal) {
                Array.from(barsEl.querySelectorAll('.bar-row')).forEach(row => {
                    const label = row.id.replace('bar-', '');
                    if (!existing.has(label)) row.remove();
                });
            }
        }

        /* =================== Intro Flow =================== */
        window.addEventListener("load", () => {
            speak(welcomeText, () => {
                document.body.classList.add("bg-white");
                document.getElementById("centerNumber").classList.add("hide");
                const img = document.getElementById("gameImg");
                img.style.display = "block"; img.classList.remove("to-left");
                speak(afterText, () => {
                    const mask = document.getElementById("mask"); mask.classList.add("show");
                    setTimeout(async () => {
                        mask.classList.remove("show");
                        document.getElementById("splitContainer").style.display = "flex";
                        img.style.display = "none";
                        startCameraAndWS();

                        await ensureVideoReady(document.getElementById("video"));
                        initPoseModel();
                        initPoseMiniOverlay();

                        setInterval(() => renderBars(false), 200);
                    }, 700);
                });
            });
        });

        /* =================== Util =================== */
        function ensureVideoReady(video) {
            return new Promise((resolve) => {
                const ready = () => video.videoWidth > 0 && video.videoHeight > 0;
                if (video.readyState >= 2 && ready()) return resolve();
                let tries = 0;
                const tick = setInterval(() => { if (ready() || ++tries > 200) { clearInterval(tick); resolve(); } }, 25);
                const onCanPlay = () => { if (ready()) { video.removeEventListener('canplay', onCanPlay); clearInterval(tick); resolve(); } };
                video.addEventListener('canplay', onCanPlay);
            });
        }

        /* =================== Camera + WS + Draw =================== */
        function startCameraAndWS() {
            const video = document.getElementById('video');
            const overlay = document.getElementById('overlay');
            const wsStatus = document.getElementById('wsStatus');
            const wsDot = document.getElementById('wsDot');
            const camInfo = document.getElementById('camInfo');
            const sendFpsEl = document.getElementById('sendFps');
            const recvFpsEl = document.getElementById('recvFps');
            const latEl = document.getElementById('lat');

            let ws; let streaming = false;
            let lastSend = 0; let sendCount = 0, recvCount = 0; let lastLatency = null; let sendingNow = false;

            setInterval(() => {
                sendFpsEl.textContent = sendCount; sendCount = 0;
                recvFpsEl.textContent = recvCount; recvCount = 0;
                latEl.textContent = (lastLatency != null ? Math.round(lastLatency) : '—');
            }, 1000);

            async function openCamera() {
                const constraints = { audio: false, video: { facingMode: 'environment', width: { ideal: 1920 }, height: { ideal: 1080 }, frameRate: { ideal: 30, max: 60 } } };
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;
                const t = stream.getVideoTracks()[0]; const s = t.getSettings ? t.getSettings() : {};
                camInfo.textContent = `${s.width || '?'}×${s.height || '?'} @ ${s.frameRate || '?'}fps`;
                await video.play();
                resizeOverlay();
            }

            function resizeOverlay() {
                overlay.style.left = '0'; overlay.style.top = '0';
                overlay.style.width = '100%'; overlay.style.height = '100%';
                const dpr = Math.max(1, window.devicePixelRatio || 1);
                const cssW = overlay.clientWidth, cssH = overlay.clientHeight;
                overlay.width = Math.floor(cssW * dpr); overlay.height = Math.floor(cssH * dpr);
                overlay.getContext('2d').setTransform(dpr, 0, 0, dpr, 0, 0);
            }
            window.addEventListener('resize', resizeOverlay);

            const wsURL = (() => {
                const host = location.hostname || "localhost";
                const proto = location.protocol === "https:" ? "wss:" : "ws:";
                const WS_URL = `${proto}//${host}:8002/ws`;  //ใช้กรณีที่ server รันบนพอร์ต 8002 local และใช้  ngrok ในการรันจริง
            })();

            function connectWS() {
                try { ws = new WebSocket(wsURL); }
                catch (e) { wsStatus.textContent = 'WS: error'; wsDot.classList.remove('on'); return; }

                ws.binaryType = 'arraybuffer';
                ws.onopen = () => { wsStatus.textContent = 'WS: connected'; wsDot.classList.add('on'); };
                ws.onclose = () => { wsStatus.textContent = 'WS: disconnected'; wsDot.classList.remove('on'); if (streaming) setTimeout(connectWS, 1200); };
                ws.onerror = () => { wsStatus.textContent = 'WS: error'; wsDot.classList.remove('on'); };
                ws.onmessage = (ev) => {
                    try {
                        const msg = JSON.parse(ev.data);
                        parseServerMessageToBoxes(msg, video);
                        lastLatency = (msg.client_latency_ms != null ? msg.client_latency_ms : msg.t_ms);
                        recvCount++;
                    } catch (e) { console.warn('WS message parse error:', e); }
                };
            }

            const sendCanvas = document.createElement('canvas');
            const sendCtx = sendCanvas.getContext('2d', { willReadFrequently: false });
            function computeSendSize(vw, vh) { if (!vw || !vh) return { w: 640, h: 360 }; const sc = Math.min(1, 768 / vw); return { w: Math.round(vw * sc), h: Math.round(vh * sc) }; }
            function sendOneFrame() {
                if (!ws || ws.readyState !== 1) return;
                if (!video.videoWidth || !video.videoHeight) return;
                if (sendingNow) return;
                const now = performance.now(), interval = 1000 / 20;
                if ((now - lastSend) < interval) return;
                sendingNow = true;
                const { w, h } = computeSendSize(video.videoWidth, video.videoHeight);
                if (sendCanvas.width !== w || sendCanvas.height !== h) { sendCanvas.width = w; sendCanvas.height = h; }
                sendCtx.drawImage(video, 0, 0, w, h);
                sendCanvas.toBlob((blob) => {
                    sendingNow = false; if (!blob) return;
                    lastSend = performance.now();
                    const hdr = new TextEncoder().encode(JSON.stringify({ t0: lastSend }));
                    const hdrLen = new Uint32Array([hdr.byteLength]);
                    const reader = new FileReader();
                    reader.onload = () => {
                        const jpegArr = new Uint8Array(reader.result);
                        const packet = new Uint8Array(4 + hdr.byteLength + jpegArr.byteLength);
                        packet.set(new Uint8Array(hdrLen.buffer), 0); packet.set(hdr, 4); packet.set(jpegArr, 4 + hdr.byteLength);
                        try { ws.send(packet); sendCount++; } catch { }
                    };
                    reader.readAsArrayBuffer(blob);
                }, 'image/jpeg', 0.7);
            }

            function startLoop() {
                if ('requestVideoFrameCallback' in HTMLVideoElement.prototype) {
                    const cb = () => { if (streaming) { sendOneFrame(); video.requestVideoFrameCallback(cb); } };
                    video.requestVideoFrameCallback(cb);
                } else {
                    const id = setInterval(() => { if (!streaming) { clearInterval(id); return; } sendOneFrame(); }, 10);
                }
            }

            /* ======== ตัวช่วย Map พิกัดกล่อง → หน้าจอ (รองรับ letterbox + DPR + mirror) ======== */
            // *** ADDED: ให้กรอบวัตถุแม่นยำในทุกขนาดหน้าจอ
            function mapBoxToOverlay(b, baseW, baseH, drawW, drawH, offX, offY, mirrored = true) {
                // baseW/baseH คือขนาดต้นทาง (srcW/srcH หรือ video)
                // drawW/drawH/offset คือกรอบที่วิดีโอถูกวาดลงจริง (object-fit: contain)
                let x = b.x, y = b.y, w = b.w, h = b.h;
                if (mirrored) {
                    // กล้องถูก mirror ใน CSS → ต้อง mirror พิกัด X ของกล่องด้วย
                    x = baseW - (b.x + b.w);
                }
                const kx = drawW / baseW, ky = drawH / baseH;
                return {
                    x: offX + x * kx,
                    y: offY + y * ky,
                    w: w * kx,
                    h: h * ky
                };
            }

            function drawLabeledBox(ctx, rect, stroke, label, s = 1) { // *** ADDED (helper)
                ctx.save();
                ctx.strokeStyle = stroke;
                ctx.lineWidth = Math.max(1, 2 / s);
                ctx.beginPath();
                ctx.rect(rect.x, rect.y, rect.w, rect.h);
                ctx.stroke();

                if (label) {
                    ctx.font = `${Math.max(10, 14 / s)}px ui-sans-serif`;
                    const textW = ctx.measureText(label).width + 8;
                    const textH = (18 / s) + 6;
                    ctx.fillStyle = 'rgba(0,0,0,0.45)';
                    ctx.fillRect(rect.x, rect.y - textH, textW, textH);
                    ctx.fillStyle = stroke;
                    ctx.fillText(label, rect.x + 4, rect.y - (6 / s));
                }
                ctx.restore();
            }

            function drawPoseOnOverlay(ctx, pose, baseW, baseH, offX, offY, kx, ky) {
                if (!pose || !pose.keypoints) return;
                const minScore = 0.2;
                const mapPt = (kp) => { const p = kp.position || kp; const x = p.x ?? 0, y = p.y ?? 0; const mx = baseW - x; return { x: offX + mx * kx, y: offY + y * ky, s: kp.score ?? kp.probability ?? 0 }; };
                const EDGES = [['leftShoulder', 'rightShoulder'], ['leftShoulder', 'leftElbow'], ['leftElbow', 'leftWrist'], ['rightShoulder', 'rightElbow'], ['rightElbow', 'rightWrist'], ['leftShoulder', 'leftHip'], ['rightShoulder', 'rightHip'], ['leftHip', 'rightHip'], ['leftHip', 'leftKnee'], ['leftKnee', 'leftAnkle'], ['rightHip', 'rightKnee'], ['rightKnee', 'rightAnkle'], ['nose', 'leftEye'], ['nose', 'rightEye'], ['leftEye', 'leftEar'], ['rightEye', 'rightEar']];
                const byName = {}; for (const kp of pose.keypoints) { const n = kp.part || kp.name || ''; if (n) byName[n] = kp; }
                ctx.save(); ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.strokeStyle = '#00E5FF'; ctx.fillStyle = '#00E5FF'; ctx.lineWidth = 3;
                for (const [a, b] of EDGES) { const ka = byName[a], kb = byName[b]; if (!ka || !kb) continue; const A = mapPt(ka), B = mapPt(kb); if (A.s < 0.2 || B.s < 0.2) continue; ctx.beginPath(); ctx.moveTo(A.x, A.y); ctx.lineTo(B.x, B.y); ctx.stroke(); }
                for (const name in byName) { const P = mapPt(byName[name]); if (P.s < minScore) continue; ctx.beginPath(); ctx.arc(P.x, P.y, 4, 0, Math.PI * 2); ctx.fill(); }
                ctx.restore();
            }

            function drawLoop() {
                const ctx = overlay.getContext('2d');
                const draw = () => {
                    if (!streaming) return;

                    // ล้างแบบตรงกับพิกเซลบนจอ (DPR ถูก setTransform ไว้แล้ว)
                    ctx.clearRect(0, 0, overlay.clientWidth, overlay.clientHeight);

                    const vw = video.videoWidth, vh = video.videoHeight;
                    if (!vw || !vh) { requestAnimationFrame(draw); return; }

                    // คำนวณกรอบวิดีโอที่ถูกวาดลงใน overlay (contain + letterbox)
                    const fitScale = Math.min(overlay.clientWidth / vw, overlay.clientHeight / vh);
                    const drawW = vw * fitScale, drawH = vh * fitScale;
                    const offX = (overlay.clientWidth - drawW) / 2, offY = (overlay.clientHeight - drawH) / 2;

                    // scale สำหรับความหนาเส้น/ตัวอักษร
                    const baseW_box = (srcW || vw), baseH_box = (srcH || vh);
                    const s = Math.min(drawW / baseW_box, drawH / baseH_box);

                    // ===== วาดกล่องมนุษย์/สัตว์ด้วย mapping ที่แม่นยำ (รองรับ DPR/letterbox/mirror) =====
                    for (const b of boxesA) {
                        const mapped = mapBoxToOverlay(b, baseW_box, baseH_box, drawW, drawH, offX, offY, true);
                        const tag = `${b.label || b.class || 'human'} ${b.conf != null ? (b.conf * 100 | 0) : ''}%`;
                        drawLabeledBox(ctx, mapped, '#00FF88', tag, s);
                    }
                    for (const b of boxesB) {
                        const mapped = mapBoxToOverlay(b, baseW_box, baseH_box, drawW, drawH, offX, offY, true);
                        const tag = `${b.label || b.class || 'animal'} ${b.conf != null ? (b.conf * 100 | 0) : ''}%`;
                        drawLabeledBox(ctx, mapped, '#3b82f6', tag, s);
                    }

                    // ===== จับคู่ + คำนวณคะแนนสด =====
                    const pairs = pairAnimalsWithHumans(boxesB, boxesA);
                    const nowMs = performance.now();
                    updateCooperationForPairs(pairs, nowMs);

                    // วาดเส้นเชื่อมคู่ (จากจุดกึ่งกลาง animal → ขอบบนของ human) แบบแม่นยำหลัง mapping
                    ctx.save();
                    ctx.strokeStyle = 'rgba(255,255,255,.55)';
                    ctx.lineWidth = Math.max(1, 2 / s);
                    for (const { animal, human } of pairs) {
                        const am = mapBoxToOverlay(animal, baseW_box, baseH_box, drawW, drawH, offX, offY, true);
                        const hm = mapBoxToOverlay(human, baseW_box, baseH_box, drawW, drawH, offX, offY, true);
                        const acx = am.x + am.w / 2, acy = am.y + am.h / 2;
                        const hcx = hm.x + hm.w / 2;
                        ctx.beginPath();
                        ctx.moveTo(acx, acy);
                        ctx.lineTo(hcx, hm.y);
                        ctx.stroke();
                    }
                    ctx.restore();

                    // วาด pose บน overlay หลัก (ออฟชั่นเดิม)
                    if (DRAW_POSE_ON_MAIN) {
                        const kx_pose = drawW / vw, ky_pose = drawH / vh;
                        drawPoseOnOverlay(ctx, window.__latestPose, vw, vh, offX, offY, kx_pose, ky_pose);
                    }

                    requestAnimationFrame(draw);
                };
                requestAnimationFrame(draw);
            }

            openCamera().then(() => { connectWS(); streaming = true; startLoop(); drawLoop(); });

            /* ======= ปุ่มเสร็จสิ้น: ล็อกผล → บันทึก Firestore (Animal_ID, game1) → ย้ายหน้า ======= */
            document.getElementById('nextBtn')?.addEventListener('click', async (e) => {
                e.preventDefault();
                const btn = e.currentTarget;
                const href = btn.getAttribute('href');
                btn.textContent = 'กำลังบันทึก…'; btn.style.opacity = .85; btn.style.pointerEvents = 'none';

                // 1) ล็อกผลเฉลี่ย (ทุก 5 วิ) ต่อหัวสัตว์
                const finalMap = finalizeCooperation();   // { [animalId]: scoreInt0..100 }
                renderBars(true);
                try { sessionStorage.setItem('finalCoop', JSON.stringify(finalMap)); } catch { }

                try {
                    // 2) บันทึก Firestore ผ่าน database.js (คงพฤติกรรมเดิม)
                    const { saveGame1Result } = await import('./database.js');
                    if (typeof saveGame1Result !== 'function') throw new Error('saveGame1Result not found in database.js');

                    const userId = window.__currentUserId || 'anonymous';
                    const extra = { source: 'game1', page: location.pathname, ts: Date.now() };

                    await Promise.all(Object.entries(finalMap).map(([animalId, score]) =>
                        saveGame1Result({ userId, animalId, score, extra })
                    ));

                    // 3) ไปหน้าถัดไป
                    window.location.href = href;
                } catch (err) {
                    console.error('Save to Firestore failed:', err);
                    alert('บันทึกผลไม่สำเร็จ กรุณาลองอีกครั้ง');
                    btn.textContent = 'เสร็จสิ้น →'; btn.style.opacity = 1; btn.style.pointerEvents = '';
                }
            });
        }

        /* =================== TM Pose =================== */
        const TM_URL = "https://teachablemachine.withgoogle.com/models/E9Gz4yAP4/";
        let tmModel, tmLabelContainer;
        async function initPoseModel() {
            const modelURL = TM_URL + "model.json";
            const metadataURL = TM_URL + "metadata.json";
            tmModel = await tmPose.load(modelURL, metadataURL);

            const video = document.getElementById("video");
            tmLabelContainer = document.getElementById("pose-label-container");
            tmLabelContainer.innerHTML = "";
            for (let i = 0; i < tmModel.getTotalClasses(); i++) tmLabelContainer.appendChild(document.createElement("div"));

            const loop = async () => {
                const { pose, posenetOutput } = await tmModel.estimatePose(video);
                const prediction = await tmModel.predict(posenetOutput);

                for (let i = 0; i < prediction.length; i++) {
                    tmLabelContainer.childNodes[i].innerHTML = prediction[i].className + ": " + prediction[i].probability.toFixed(2);
                }
                window.__latestPose = pose;
                let top = prediction[0]; for (const p of prediction) if (p.probability > top.probability) top = p;
                window.__latestPoseTop = { name: top.className, prob: top.probability };

                const badge = document.getElementById('tmBadge');
                if (badge && top) badge.textContent = `${top.className} ${(top.probability * 100).toFixed(0)}%`;

                requestAnimationFrame(loop);
            };
            requestAnimationFrame(loop);
        }

        /* =================== Mini Pose Canvas =================== */
        function initPoseMiniOverlay() {
            const mini = document.getElementById("tmMini");
            const canvas = document.getElementById("tmMiniCanvas");
            const ctx = canvas.getContext("2d");
            const video = document.getElementById("video");

            const resize = () => {
                const dpr = Math.max(1, window.devicePixelRatio || 1);
                const rect = mini.getBoundingClientRect();
                const cssW = Math.max(1, rect.width);
                const cssH = Math.max(1, rect.height);
                canvas.width = Math.floor(cssW * dpr);
                canvas.height = Math.floor(cssH * dpr);
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            };
            resize();
            window.addEventListener("resize", resize);
            new ResizeObserver(resize).observe(mini);

            const render = () => {
                const cw = mini.clientWidth, ch = mini.clientHeight;
                ctx.clearRect(0, 0, cw, ch);

                const vw = video.videoWidth, vh = video.videoHeight;
                if (vw && vh && cw > 0 && ch > 0) {
                    const scale = Math.min(cw / vw, ch / vh);
                    const drawW = vw * scale, drawH = vh * scale;
                    const offX = (cw - drawW) / 2, offY = (ch - drawH) / 2;

                    ctx.save();
                    ctx.translate(offX + drawW, offY);
                    ctx.scale(-scale, scale);
                    ctx.drawImage(video, 0, 0, vw, vh);
                    ctx.restore();

                    const pose = window.__latestPose;
                    if (pose && pose.keypoints) {
                        ctx.save();
                        ctx.translate(offX, offY);
                        ctx.scale(scale, scale);
                        ctx.translate(vw, 0); ctx.scale(-1, 1);
                        const minScore = 0.2;
                        tmPose.drawKeypoints(pose.keypoints, minScore, ctx);
                        tmPose.drawSkeleton(pose.keypoints, minScore, ctx);
                        ctx.restore();
                    }
                }
                requestAnimationFrame(render);
            };
            requestAnimationFrame(render);
        }
    </script>
</body>

</html>